{"body":"## 概要\n\nAuto-Yesモードを有効化後、**バックグラウンドでは正常動作**するが、**UIは「オフ」と表示**される問題。\n\n**優先度: 高** - 本番環境でも発生することを確認済み\n\n## 再現手順\n\n1. サーバー起動（開発モード or 本番モード）\n2. Worktree詳細画面でAuto-Yesを有効化\n3. しばらく待つ\n4. UIを確認 → トグルが「オフ」表示\n5. サーバーログを確認 → `[Auto-Yes Poller] Sent response` が出力され続けている（可能性）\n\n## 確認された事実\n\n| 項目 | 実際の状態 |\n|------|-----------|\n| サーバーログ | `[Auto-Yes Poller] Sent response` ✅ 動作中（要確認） |\n| GET `/auto-yes` API | `{ enabled: false }` ❌ |\n| GET `/current-output` API | `{ autoYes: { enabled: false }, lastServerResponseTimestamp: null }` ❌ |\n| UIトグル | オフ ❌ |\n\n## 根本原因\n\n**インメモリ状態管理の脆弱性**\n\n`auto-yes-manager.ts` はインメモリの `Map` で状態を管理しているため、以下の状況で状態がリセットされる：\n\n| 環境 | 原因 |\n|------|------|\n| 開発環境 | Next.jsホットリロードによるモジュール再読み込み |\n| 本番環境 | Next.jsワーカー再起動、メモリ圧力、APIルートのコールドスタート |\n\n**該当コード**: `src/lib/auto-yes-manager.ts:78-81`\n\n```typescript\nconst autoYesStates = new Map<string, AutoYesState>();\nconst autoYesPollerStates = new Map<string, AutoYesPollerState>();\n```\n\n### モジュール再読み込み時の動作\n\n1. ユーザーがAuto-Yesを有効化 → `Map.set()`, `setTimeout()` でポーリング開始\n2. モジュール再読み込み発生 → **Mapが新しい空のインスタンスで初期化**\n3. **旧setTimeout**はNode.jsイベントループで継続動作（旧Mapを参照）\n4. UIがGETリクエスト → 新モジュールの空Mapを参照 → `enabled: false`\n\n## 影響\n\n| APIエンドポイント | 影響 |\n|------------------|------|\n| `GET /auto-yes` | `enabled: false` を返却 |\n| `GET /current-output` | `autoYes.enabled: false`, `lastServerResponseTimestamp: null` を返却 |\n| `POST /auto-yes` (OFF) | 新Mapを操作するため旧ポーラーは停止しない |\n\n**追加の影響**:\n- UIが実態と乖離し、ユーザーが混乱\n- UIからOFFにしても旧ポーラーは停止しない（新Mapを操作するだけ）\n- `lastServerResponseTimestamp`が更新されず、クライアント側重複防止機能が無効化\n- 最悪の場合、サーバーとクライアント両方が同じプロンプトに応答する可能性\n\n## 調査項目（実装前に確認）\n\n- [ ] 本番環境のサーバーログで `[Auto-Yes Poller]` の動作状況を確認\n- [ ] 問題発生時のタイムスタンプとサーバーログの相関を確認\n- [ ] Next.jsのワーカー再起動ログの有無を確認\n\n## 推奨される改善策\n\n### 案1: グローバル状態による永続化（推奨）\n\n```typescript\n// globalThisを使用してモジュール再読み込み耐性を確保\ndeclare global {\n  // eslint-disable-next-line no-var\n  var __autoYesStates: Map<string, AutoYesState> | undefined;\n  // eslint-disable-next-line no-var\n  var __autoYesPollerStates: Map<string, AutoYesPollerState> | undefined;\n}\n\nconst autoYesStates = globalThis.__autoYesStates ?? \n  (globalThis.__autoYesStates = new Map<string, AutoYesState>());\n\nconst autoYesPollerStates = globalThis.__autoYesPollerStates ?? \n  (globalThis.__autoYesPollerStates = new Map<string, AutoYesPollerState>());\n```\n\n**メリット**: 実装コスト低（〜20行）、開発・本番両環境で有効\n**デメリット**: テスト時に状態リセットの考慮が必要\n\n### 案2: DB永続化\n\n- SQLiteの `worktrees` テーブルに `auto_yes_enabled`, `auto_yes_expires_at` カラムを追加\n- ポーラー状態はメモリ管理のまま、サーバー起動時にDB状態と同期\n\n**メリット**: 最も信頼性が高い、サーバー再起動後も状態復元可能\n**デメリット**: 実装コスト高（マイグレーション + CRUD）\n\n### 案3: サーバー起動時クリーンアップ\n\n- 孤児ポーラーの検出・停止機構を追加\n- graceful shutdown時に全ポーラーを確実に停止\n\n**メリット**: 孤児ポーラー問題を解決\n**デメリット**: 状態不整合の根本解決にはならない\n\n### 実装案の比較\n\n| 評価項目 | 案1: globalThis | 案2: DB永続化 | 案3: クリーンアップ |\n|---------|----------------|--------------|------------------|\n| 実装コスト | **低** | 高 | 中 |\n| 信頼性 | 高 | **最高** | 低 |\n| 本番影響 | なし | カラム追加 | なし |\n| 推奨度 | **★★★** | ★★ | ★ |\n\n## 受け入れ条件\n\n- [ ] Auto-Yesを有効化後、モジュール再読み込みが発生してもUI状態が正しく表示されること\n- [ ] UIからOFFにした場合、バックグラウンドポーラーも確実に停止すること\n- [ ] `lastServerResponseTimestamp`が正しく更新されること\n- [ ] 開発環境・本番環境の両方で問題が発生しないことを確認\n\n## テスト計画\n\n### 手動検証手順（開発環境）\n\n1. `npm run dev` でサーバー起動\n2. Worktree詳細画面でAuto-Yesを有効化\n3. `src/lib/auto-yes-manager.ts` に空白行を追加して保存（ホットリロード発生）\n4. UIのトグル状態が「オン」のままであることを確認\n5. サーバーログで `[Auto-Yes Poller]` のログが継続していることを確認\n\n### 手動検証手順（本番環境）\n\n1. `npm run build && npm start` でサーバー起動\n2. Worktree詳細画面でAuto-Yesを有効化\n3. 数分〜数十分待機\n4. UIのトグル状態が「オン」のままであることを確認\n\n## 関連Issue\n\n- Issue #138: サーバー側Auto-Yesポーリング実装（この問題の原因となった機能）\n\n## 関連コード\n\n- `src/lib/auto-yes-manager.ts:78-81` - インメモリMapの宣言\n- `src/lib/auto-yes-manager.ts:312-314` - `setTimeout`でポーリングをスケジュール\n- `src/lib/auto-yes-manager.ts:358-360` - ポーリング開始時の`setTimeout`\n- `src/app/api/worktrees/[id]/auto-yes/route.ts` - Auto-Yes API\n- `src/app/api/worktrees/[id]/current-output/route.ts` - 状態取得API\n- `src/hooks/useAutoYes.ts` - クライアント側フック","title":"fix: Auto-Yes UIとバックグラウンドの状態不整合（ホットリロード時）"}
