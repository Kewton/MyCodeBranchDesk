{
  "issue_number": 190,
  "focus_area": "整合性",
  "stage": 2,
  "stage_name": "整合性レビュー",
  "status": "conditionally_approved",
  "score": 4,
  "findings": {
    "must_fix": [
      {
        "id": "MF-C01",
        "category": "関数シグネチャ整合性",
        "title": "createRepository() の呼び出しパラメータに isEnvManaged: true を渡しているが、既存シグネチャでは isEnvManaged はオプション(boolean | undefined)かつデフォルトfalse相当",
        "description": "設計書 Section 5 の ensureEnvRepositoriesRegistered() 内で createRepository(db, { ..., isEnvManaged: true, enabled: true }) と呼び出しているが、既存の createRepository() のパラメータ型は isEnvManaged?: boolean であり enabled?: boolean である。型としては互換だが、enabled のデフォルト処理が data.enabled !== false ? 1 : 0 となっており、enabled: true を明示的に渡す設計は正しく動作する。一方、disableRepository() 内の createRepository(db, { ..., enabled: false }) は data.enabled !== false の条件で 0 にマップされる。この挙動は設計意図と一致するが、enabled のデフォルト値ロジック（!== false で判定）が直感的でないため、実装時にバグ混入リスクがある。",
        "severity": "medium",
        "recommendation": "createRepository() の enabled デフォルト値ロジック（data.enabled !== false ? 1 : 0）をコードコメントで明文化し、設計書にもこの挙動を注記すること。enabled を undefined で渡した場合は 1（有効）になる点を明示する。"
      }
    ],
    "should_fix": [
      {
        "id": "SF-C01",
        "category": "データフロー整合性",
        "title": "DELETE /api/repositories の既存フローで worktreeIds.length === 0 時に 404 を返す動作と、disableRepository() 呼び出しタイミングの整合性",
        "description": "設計書 Section 2 の削除フローでは disableRepository() の呼び出しを記載しているが、既存の route.ts では worktreeIds.length === 0 の場合に早期リターン(404)している。環境変数で設定されたリポジトリがまだ一度も Sync All されていない場合（worktrees テーブルにレコードが無い場合）、DELETE API は 404 を返し、disableRepository() が呼ばれない。この場合、除外登録されないまま次の Sync All で復活する可能性がある。",
        "severity": "medium",
        "recommendation": "disableRepository() の呼び出しを worktreeIds チェックの前（バリデーション直後）に移動するか、worktreeIds === 0 でも disableRepository() は実行する制御フローに変更すること。設計書 Section 2 の削除フロー図にこの制御フローの詳細を追記すること。"
      },
      {
        "id": "SF-C02",
        "category": "パス正規化整合性",
        "title": "getRepositoryPaths() が返すパスと repositories.path の正規化レベルの差異",
        "description": "既存の getRepositoryPaths() は .trim() のみを適用し path.resolve() を適用しない（worktrees.ts line 126-129）。一方、scanWorktrees() は path.resolve(rootDir) を適用する（worktrees.ts line 166）。設計書 Section 7 でこの問題を認識し resolveRepositoryPath() で正規化を集約する方針だが、filterExcludedPaths() 内での比較が Array.includes() を使っており、パスの末尾スラッシュやシンボリックリンク解決による不一致が発生しうる。path.resolve() は末尾スラッシュを除去するがシンボリックリンクは解決しない。",
        "severity": "medium",
        "recommendation": "filterExcludedPaths() のパス比較において、getRepositoryPaths() の各パスに resolveRepositoryPath() を適用後、excludedPaths との比較を行う現設計は正しいが、シンボリックリンクのケースについて設計書に明記すること。必要に応じて fs.realpathSync() の使用を検討し、既存の db-path-resolver.ts や env-setup.ts での realpath 使用パターンと整合させること。"
      },
      {
        "id": "SF-C03",
        "category": "APIパターン整合性",
        "title": "PUT /api/repositories/restore のHTTPメソッド選択がプロジェクトの既存パターンと不整合",
        "description": "既存プロジェクトでは状態変更に PATCH を使用するパターンが多い（例: PATCH /api/worktrees/:id で description/link/favorite/status 更新）。restore API は enabled フラグの部分更新であり、意味的には PATCH が適切。ただし、restore は単なるフラグ更新に加えて scanWorktrees + syncWorktreesToDB という副作用を伴うため、PUT の選択にも合理性がある。",
        "severity": "low",
        "recommendation": "現設計の PUT を維持するか PATCH に変更するかの設計判断をセクション 13 のトレードオフテーブルに明記すること。副作用を伴うため PUT が選択された理由を記載すれば十分。"
      },
      {
        "id": "SF-C04",
        "category": "セクション間整合性",
        "title": "Section 4.1 と Section 2 の sync/route.ts オーケストレーションコード例の微妙な差異",
        "description": "Section 2 の処理フロー図では ensureEnvRepositoriesRegistered() の後に filterExcludedPaths() を呼ぶ順序を示しているが、Section 4.1 のコード例では getRepositoryPaths() の後に ensureEnvRepositoriesRegistered() と filterExcludedPaths() を順次呼ぶ。両者は同じ意図だが、Section 2 のフロー図では getDbInstance() の呼び出しが省略されている。実装時の混乱を避けるため、フロー図とコード例の粒度を一致させることが望ましい。",
        "severity": "low",
        "recommendation": "Section 2 のフロー図に getDbInstance() の呼び出しを追加するか、フロー図は概念レベルであることを注記すること。"
      }
    ],
    "consider": [
      {
        "id": "C-C01",
        "category": "既存コード整合性",
        "title": "scan/route.ts もリポジトリを worktrees テーブルに登録するが、repositories テーブルには登録しない",
        "description": "設計書 Section 15 でスコープ外として認識されているが、scan/route.ts で手動スキャンしたリポジトリは repositories テーブルに登録されないため、除外対象にもならない。DELETE API で worktreeIds が0の場合の早期リターン(404)問題（SF-C01）と組み合わさると、scan 経由で登録されたリポジトリは「削除してもSync Allで復活」の問題は発生しないが、repositories テーブルとの不整合が生じる。",
        "recommendation": "フォローアップ Issue として明確に記録すること（設計書に既に記載あり。優先度の明確化を推奨）。"
      },
      {
        "id": "C-C02",
        "category": "データモデル整合性",
        "title": "repositories テーブルの enabled カラムが clone 機能と除外機能で意味的に共有される",
        "description": "設計書 Section 13 でトレードオフとして認識済み。clone_jobs テーブル経由で登録されたリポジトリ（clone_source = 'https'/'ssh'）の enabled を 0 にした場合、クローン機能側の挙動への影響が不明確。現時点では clone 機能に enabled ベースのフィルタリングは実装されていないため直接的な問題はないが、将来の拡張時に注意が必要。",
        "recommendation": "設計書にクローンリポジトリの enabled=0 時の挙動について一文追記すること。"
      },
      {
        "id": "C-C03",
        "category": "UI整合性",
        "title": "WorktreeList.tsx の isInEnvVar() 関数は NEXT_PUBLIC_WORKTREE_REPOS を参照するが、設計書では警告メッセージ全体の置換を提案",
        "description": "設計書 Section 6.1 では削除確認ダイアログの警告メッセージを完全に置換する方針だが、既存の isInEnvVar() ヘルパー関数が不要になるかどうかが明示されていない。新メッセージでは環境変数に依存しない統一メッセージになるため、isInEnvVar() の呼び出しが不要になる可能性がある。",
        "recommendation": "isInEnvVar() 関数の使用継続/廃止について設計書に明記すること。廃止する場合はデッドコード削除も変更対象ファイル一覧に含めること。"
      }
    ]
  },
  "consistency_checklist": {
    "code_structure": {
      "status": "pass",
      "notes": "設計書のレイヤー構成（API -> ビジネスロジック -> データアクセス）は既存コードのパターンと一致。db-repository.ts へのロジック集約は既存の Repository/CloneJob 操作パターンと整合。"
    },
    "function_signatures": {
      "status": "conditionally_pass",
      "notes": "createRepository() / updateRepository() / getRepositoryByPath() の既存シグネチャと設計書の提案する呼び出し方は型レベルで互換。ただし MF-C01 の enabled デフォルト値挙動に注意。"
    },
    "data_model": {
      "status": "pass",
      "notes": "repositories テーブル（Migration #14）の既存スキーマと設計書 Section 3 のテーブル定義は完全一致。enabled, is_env_managed, clone_source カラムの定義とデフォルト値が一致。新規マイグレーション不要の判断は正しい。"
    },
    "api_endpoints": {
      "status": "conditionally_pass",
      "notes": "既存 API パターン（NextRequest/NextResponse, getDbInstance(), try-catch, JSON レスポンス）と整合。DELETE /api/repositories の既存フローとの統合に SF-C01 の課題あり。新規 API（excluded, restore）のパス構成は既存の /api/repositories/scan, /api/repositories/clone パターンに準拠。"
    },
    "cross_section_consistency": {
      "status": "conditionally_pass",
      "notes": "SF-C04 の Section 2 / Section 4.1 間の粒度差異があるが、意図は整合。Section 5 の関数設計と Section 11 の変更対象ファイル一覧は一致。Section 12 のテストケースは Section 5 の関数を網羅。"
    }
  },
  "risk_assessment": {
    "technical": "low",
    "security": "low",
    "operational": "medium"
  },
  "reviewed_files": [
    "dev-reports/design/issue-190-repository-exclusion-on-sync-design-policy.md",
    "src/lib/db-repository.ts",
    "src/lib/worktrees.ts",
    "src/lib/db.ts",
    "src/lib/db-instance.ts",
    "src/lib/db-migrations.ts",
    "src/lib/api-client.ts",
    "src/app/api/repositories/route.ts",
    "src/app/api/repositories/sync/route.ts",
    "src/app/api/repositories/scan/route.ts",
    "src/components/worktree/WorktreeList.tsx"
  ],
  "timestamp": "2026-02-08T12:00:00Z"
}
