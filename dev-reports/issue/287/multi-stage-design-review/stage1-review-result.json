{
  "issue_number": 287,
  "focus_area": "設計原則",
  "stage": 1,
  "stage_name": "通常レビュー",
  "status": "conditionally_approved",
  "score": 4,
  "findings": {
    "must_fix": [
      {
        "id": "MF-001",
        "principle": "DRY",
        "title": "route.ts と auto-yes-manager.ts のカーソルキー送信ロジックの重複",
        "description": "設計方針書のセクション12でDRYに警告マークが付けられており、route.ts (L96-158) と auto-yes-manager.ts (L343-399) のカーソルキー送信ロジックが完全に重複している。Issue #287の変更でフォールバックロジックを route.ts にのみ追加すると、2つのコードパスの乖離がさらに拡大する。別Issueとして分離する方針は理解するが、Issue #287のフォールバック変更自体が重複コードの片方にのみ適用されるため、将来の整合性リスクが高い。フォールバック導入前に、少なくとも共通ヘルパー関数の抽出を検討すべき。",
        "recommendation": "カーソルキー送信ロジック(isClaudeMultiChoice判定、offset計算、keys配列構築、multi-select判定)を src/lib/cursor-key-sender.ts 等の共通ヘルパーに抽出し、route.ts と auto-yes-manager.ts の両方から呼び出す。フォールバック用の defaultNum パラメータを引数として受け取る設計にすれば、Issue #287の変更もヘルパー側に集約できる。ただし設計方針書で別Issue対応と明記されているため、Issue #287のスコープ内で必須とするかはチーム判断。",
        "severity": "medium",
        "affected_files": [
          "src/app/api/worktrees/[id]/prompt-response/route.ts",
          "src/lib/auto-yes-manager.ts"
        ]
      }
    ],
    "should_fix": [
      {
        "id": "SF-001",
        "principle": "SRP",
        "title": "route.ts の POST 関数が複数の責務を持つ",
        "description": "route.ts の POST 関数は約180行あり、(1)リクエスト検証、(2)worktree存在確認、(3)セッション確認、(4)プロンプト再検証、(5)送信方式判定(isClaudeMultiChoice)、(6)カーソルキー構築とsendSpecialKeys呼び出し、(7)テキスト送信、の7つの責務を1関数で担っている。Issue #287のフォールバック追加で(5)の条件分岐がさらに複雑化する。",
        "recommendation": "送信方式判定+キー送信ロジックを別関数(例: sendPromptAnswer(sessionName, answer, promptCheck, fallbackData))として抽出する。これによりフォールバック判定のテスタビリティも向上する。",
        "severity": "low"
      },
      {
        "id": "SF-002",
        "principle": "KISS",
        "title": "isClaudeMultiChoice の二重条件チェック",
        "description": "現在の route.ts (L96-100) では isClaudeMultiChoice の判定で promptCheck?.promptData?.type === 'multiple_choice' を使い、直後の if文 (L100) で再度同じ条件を確認している。フォールバック追加後はこのパターンがさらに読みにくくなる(promptCheck優先 + body.promptType フォールバック)。設計方針書のセクション6のコード例は論理的に正しいが、1つの条件式に OR演算子で2つのソースを混在させるため、意図の読み取りに認知コストがかかる。",
        "recommendation": "判定を2段階に分離する。まず effectivePromptType を決定(promptCheck?.promptData?.type ?? body.promptType)、次に isClaudeMultiChoice を effectivePromptType === 'multiple_choice' で判定する。同様に effectiveDefaultNum も事前に決定する。これにより条件式がシンプルになり、デバッグ時のトレーサビリティも向上する。",
        "severity": "low"
      },
      {
        "id": "SF-003",
        "principle": "DRY",
        "title": "handlePromptRespond と useAutoYes のリクエストボディ構築の重複",
        "description": "Issue #287では handlePromptRespond (WorktreeDetailRefactored.tsx) と useAutoYes.ts の両方で promptType / defaultOptionNumber を導出してリクエストボディに追加する。導出ロジック(promptData?.type の取得、options.find(o => o.isDefault)?.number の計算)が2箇所に重複する。",
        "recommendation": "リクエストボディ構築を共通ユーティリティ関数(例: buildPromptResponseBody(answer, cliTool, promptData))として抽出し、両方から呼び出す。これにより将来フィールドが追加された場合も1箇所の修正で済む。",
        "severity": "low"
      }
    ],
    "consider": [
      {
        "id": "C-001",
        "principle": "OCP",
        "title": "PromptResponseRequest のローカル定義維持",
        "description": "設計方針書 D-4 で PromptResponseRequest を route.ts のローカル定義のまま維持する方針が示されている。YAGNI準拠の判断として妥当だが、クライアント側で JSON.stringify で直接オブジェクトリテラルを構築する現在のパターンでは、フィールド名のtypoやフィールド漏れがコンパイル時に検出されない。将来的に型共有化の際、Open/Closed Principle に基づいてインターフェースを拡張ポイントとして設計する余地がある。",
        "recommendation": "本Issueでは対応不要。将来の型共有化Issueで検討。ただし、少なくともクライアント側に PromptResponseRequestBody のような型エイリアスを定義し、JSON.stringify の引数に型注釈を付けることを検討。"
      },
      {
        "id": "C-002",
        "principle": "LSP",
        "title": "D-5: defaultOptionNumber ?? 1 のフォールバックデフォルト値",
        "description": "設計方針書の D-5 で defaultOptionNumber が未定義の場合に 1 をフォールバックとしている。既存コードの defaultOption?.number ?? 1 と一貫性があるが、デフォルトが1でないケース(例: 2番目の選択肢がデフォルトの場合)にフォールバックパスでは常にカーソルが1を起点に計算される。これはLSP的に「フォールバックパスが通常パスと同等の振る舞いを保証しない」ケースを生む。",
        "recommendation": "設計方針書で既にトレードオフとして認識済み。頻度が極めて低いエッジケースであるため現状維持で問題なし。テストケース #5 がこのケースをカバーしている点は評価できる。"
      },
      {
        "id": "C-003",
        "principle": "DRY / Future",
        "title": "D-6: multi-select フォールバック非対応",
        "description": "フォールバックパスで multi-select を single-select として処理する設計判断は YAGNI に準拠しており妥当。ただし、将来 multi-select の使用頻度が増加した場合、UIから options データも送信する拡張が必要になる可能性がある。",
        "recommendation": "現状維持。captureSessionOutput の安定性向上が根本対策であり、フォールバックの充実よりも正常パスの信頼性向上を優先すべき。"
      },
      {
        "id": "C-004",
        "principle": "KISS",
        "title": "useCallback dependency への state.prompt.data 追加の影響",
        "description": "設計方針書セクション9でパフォーマンス影響は無視できると分析されているが、handlePromptRespond の useCallback が state.prompt.data を依存に持つことで、ポーリング毎にプロンプトデータが更新される度に関数が再生成される。React.memo で保護されているとはいえ、依存配列の肥大化はメンテナンス性に影響する。",
        "recommendation": "state.prompt.data を useRef に格納し、handlePromptRespond 内でref.current を参照する既存パターン(activeCliTabRef と同様)を採用することで、useCallback の依存配列に追加する必要がなくなる。"
      }
    ]
  },
  "risk_assessment": {
    "technical": "low",
    "security": "low",
    "operational": "low"
  },
  "design_principles_evaluation": {
    "single_responsibility": {
      "status": "partial",
      "score": 3,
      "notes": "route.ts のPOST関数が多責務。フォールバック追加で条件分岐が増加するが、設計方針書のスコープ制限により許容範囲。"
    },
    "open_closed": {
      "status": "pass",
      "score": 4,
      "notes": "onRespond シグネチャを不変に保つ非破壊的アプローチは OCP に準拠。PromptResponseRequest のオプショナルフィールド追加も後方互換性を維持。"
    },
    "liskov_substitution": {
      "status": "partial",
      "score": 3,
      "notes": "フォールバックパスが通常パスと完全に同等の振る舞いを保証しない(multi-select非対応、defaultOptionNumber ?? 1)。ただしエッジケースとして許容。"
    },
    "interface_segregation": {
      "status": "pass",
      "score": 4,
      "notes": "UIコンポーネントのインターフェースに影響を与えない設計。新規フィールドはAPIレベルのみ。"
    },
    "dependency_inversion": {
      "status": "pass",
      "score": 4,
      "notes": "UI層→API層の依存方向は適切。state.prompt.data からの内部取得はクロージャ経由だが、既存パターンと一貫性がある。"
    },
    "kiss": {
      "status": "pass",
      "score": 4,
      "notes": "promptCheck ?? body.promptType のフォールバックは概念的にシンプル。ただし実際のコード表現(OR条件の複合式)にやや複雑性あり。"
    },
    "yagni": {
      "status": "pass",
      "score": 5,
      "notes": "型共有化の延期、multi-select フォールバック非対応、スコープの明確な限定。YAGNI準拠が優れている。"
    },
    "dry": {
      "status": "partial",
      "score": 3,
      "notes": "既存のカーソルキーロジック重複を解消せずにフォールバックを追加することで、乖離リスクが増大。リクエストボディ構築の重複も新規発生。"
    }
  },
  "reviewed_files": [
    "dev-reports/design/issue-287-prompt-response-fallback-design-policy.md",
    "src/app/api/worktrees/[id]/prompt-response/route.ts",
    "src/components/worktree/WorktreeDetailRefactored.tsx",
    "src/hooks/useAutoYes.ts",
    "src/lib/auto-yes-manager.ts",
    "src/types/models.ts",
    "src/lib/prompt-detector.ts",
    "tests/unit/api/prompt-response-verification.test.ts"
  ],
  "timestamp": "2026-02-15T12:00:00Z"
}
