{
  "issue_number": 190,
  "focus_area": "設計原則",
  "stage": 1,
  "stage_name": "通常レビュー",
  "status": "conditionally_approved",
  "score": 4,
  "findings": {
    "must_fix": [
      {
        "id": "MF-001",
        "principle": "SRP",
        "title": "sync/route.ts に環境変数リポジトリ自動登録ロジックを直接配置",
        "description": "設計書では sync/route.ts 内に環境変数リポジトリの自動登録ループ（for...of + getRepositoryByPath + createRepository）を直接記述している。このロジックはデータアクセス層（db-repository.ts）またはビジネスロジック層（worktrees.ts）に属するべき。API routeの責務はリクエスト処理とレスポンス構築であり、ビジネスロジックの混入はSRP違反。",
        "recommendation": "ensureEnvRepositoriesRegistered(db, repositoryPaths) のような関数を db-repository.ts または worktrees.ts に切り出し、sync/route.ts からは呼び出すだけにする。",
        "severity": "medium"
      }
    ],
    "should_fix": [
      {
        "id": "SF-001",
        "principle": "DRY",
        "title": "path.resolve() によるパス正規化が複数箇所に分散",
        "description": "設計書のコード例では path.resolve() を DELETE route、sync route、フィルタリング比較時など複数箇所で個別に呼び出している。正規化忘れがバグに直結するため、入口で一度正規化する関数を用意すべき。",
        "recommendation": "db-repository.ts に resolveAndNormalizePath() のようなヘルパーを用意するか、getRepositoryByPath() の内部で path.resolve() を適用して呼び出し側の責務を軽減する。",
        "severity": "low"
      },
      {
        "id": "SF-002",
        "principle": "SRP",
        "title": "DELETE route の repositories テーブル操作が route.ts に直接記述",
        "description": "設計書では DELETE /api/repositories の route.ts 内に getRepositoryByPath + updateRepository / createRepository のロジックを直接記述している。既存の route.ts はセッションクリーンアップとworktrees物理削除のみを行っており、repositoriesテーブル操作は別レイヤーに分離すべき。",
        "recommendation": "disableRepository(db, repositoryPath) のようなファサード関数を db-repository.ts に追加し、route.ts からは1関数呼び出しにする。内部で「既存ならenabled=0更新、未登録ならenabled=0で新規登録」を処理する。",
        "severity": "low"
      },
      {
        "id": "SF-003",
        "principle": "OCP",
        "title": "除外判定ロジックの拡張性",
        "description": "現在の設計ではフィルタリングが sync/route.ts 内の Array.filter + includes で行われている。将来、除外条件が増えた場合（例: パターンベース除外、一時的除外）にこのAPIルートを直接変更する必要がある。",
        "recommendation": "filterExcludedPaths(db, repositoryPaths) のような関数を worktrees.ts に配置し、除外判定ロジックをカプセル化する。これにより除外条件の変更がAPIルートに影響しない。",
        "severity": "low"
      },
      {
        "id": "SF-004",
        "principle": "KISS",
        "title": "復活API内での自動sync実行の複雑性",
        "description": "PUT /api/repositories/restore が enabled=1 更新だけでなく scanWorktrees() + syncWorktreesToDB() も自動実行する設計。設計書自身がトレードオフとして「API応答が遅くなる可能性」を認めている。復活とsyncを分離した方がシンプル。",
        "recommendation": "restore API は enabled=1 更新のみに限定し、worktrees の復元はユーザーが手動で Sync All を実行する方式を検討する。もしくは非同期ジョブとして実行する。ただしUXとのトレードオフがあるため、現設計も許容範囲。"
      }
    ],
    "consider": [
      {
        "id": "C-001",
        "principle": "YAGNI",
        "title": "getExcludedRepositoryPaths() と getExcludedRepositories() の2関数",
        "description": "getExcludedRepositoryPaths() はパスのみを返し、getExcludedRepositories() は全詳細を返す。現設計では前者は sync/route.ts のフィルタリング用、後者は excluded API 用。フィルタリングに必要なのはパスのみなので前者は合理的だが、getExcludedRepositories() から paths を抽出すれば1関数で済む可能性もある。",
        "recommendation": "パフォーマンス要件がなければ getExcludedRepositories() のみにして .map(r => r.path) で対応可能。ただし現設計でもオーバーヘッドは最小限のため、そのままでも問題ない。"
      },
      {
        "id": "C-002",
        "principle": "DIP",
        "title": "sync/route.ts から db-repository.ts への直接依存",
        "description": "sync/route.ts が db-repository.ts の具体的な関数を直接importする設計。現時点のプロジェクト規模では問題ないが、将来のテスタビリティを考慮するとインターフェースを介した依存注入が望ましい。",
        "recommendation": "現段階では直接依存で十分。プロジェクトが大規模化した場合にリファクタリングを検討する。"
      },
      {
        "id": "C-003",
        "principle": "YAGNI",
        "title": "scan/route.ts のスコープ外判断",
        "description": "設計書が scan/route.ts 経由のリポジトリ登録をスコープ外としている点は適切。scan/route.ts は個別スキャン用途であり、除外機能と直接関連しない。フォローアップIssue候補として記録されている点も良い。",
        "recommendation": "現設計のスコープ判断を維持する。"
      }
    ]
  },
  "risk_assessment": {
    "technical": "low",
    "security": "low",
    "operational": "low"
  },
  "design_principles_checklist": {
    "SRP": {
      "status": "partial",
      "notes": "sync/route.ts と DELETE route.ts にビジネスロジックが混入している。db-repository.ts のデータアクセス関数自体はSRP準拠。"
    },
    "OCP": {
      "status": "partial",
      "notes": "除外フィルタリングロジックがAPIルートに直接埋め込まれており、除外条件変更時にルートの修正が必要。ただし現要件では1パターンのみのため実害は小さい。"
    },
    "LSP": {
      "status": "pass",
      "notes": "新規関数はRepository型の既存契約に従っている。createRepository の enabled パラメータも既存シグネチャと整合。"
    },
    "ISP": {
      "status": "pass",
      "notes": "Repository インターフェースは既存のものを再利用しており、不要なプロパティの追加はない。API レスポンスも必要最小限の情報を返している。"
    },
    "DIP": {
      "status": "acceptable",
      "notes": "具体実装への直接依存だが、プロジェクト規模から適切。"
    },
    "KISS": {
      "status": "pass",
      "notes": "既存の enabled カラムを活用する設計は新テーブル追加と比較して非常にシンプル。不採用パターンの判断も適切。"
    },
    "YAGNI": {
      "status": "pass",
      "notes": "スコープ外事項が明確に定義されており、必要最小限の機能に絞られている。新規マイグレーション不要な点も評価できる。"
    },
    "DRY": {
      "status": "partial",
      "notes": "path.resolve() 呼び出しが複数箇所に分散。mapRepositoryRow 等の既存ユーティリティは適切に再利用されている。"
    }
  },
  "reviewed_files": [
    "dev-reports/design/issue-190-repository-exclusion-on-sync-design-policy.md",
    "src/lib/db-repository.ts",
    "src/app/api/repositories/route.ts",
    "src/app/api/repositories/sync/route.ts",
    "src/app/api/repositories/scan/route.ts",
    "src/lib/worktrees.ts",
    "src/lib/session-cleanup.ts",
    "src/components/worktree/WorktreeList.tsx",
    "src/lib/api-client.ts",
    "src/lib/db-migrations.ts"
  ],
  "timestamp": "2026-02-08T00:00:00Z"
}
